## transaction

1. 一次执行多个命令, 一个事务中的所有的命令都会序列化, 串行的排他的执行

   - watch: 可以在事务之前也可以之后, 是一个乐观锁, redis 事务提供的 cas 行为, 可以监控一个或多个 key, 一旦其中的值被修改或删除, 之后的事务就不会执行, 监控知道 exec 命令结束
   - multi 开始事务, 会将客户端状态的 flags 属性打开 redis_multi 标识, 接下来的命令都会以 redis_multi 为起点的 queued
   - queued, 入 queue 的语法错误则关闭 redis_multi[事务结束], 并返回错误信息; 否则入 queue
   - exec/discard: 如果客户端的 flags 不包含 redis_multi 或者包含了 redis_dirty_cas 或者 包含了 redis_dity_exec 则取消事务的执行, 否则认为可以执行事务[遍历事务 queue FIFO, 顺序输出结果, 且逻辑的错误不会回滚整个事务]

2. command

   ```js
   discard // 取消事务, 放弃事务内的所有命令
   exec    // 执行事务内的所有的命令
   multi   // 标记事务块的开始
   unwatch // 取消watch 命令对所有key的监视
   watch key [key ...] // 监视key, 如果事务执行之前被watch则事务会被打断
   ```

3. practice: **两个客户端之间的顺序是谁的 exec 先达到谁先执行**

   - normal case

   ```shell
   127.0.0.1:6379> MULTI
   OK
   127.0.0.1:6379> set id 12
   QUEUED
   127.0.0.1:6379> get id
   QUEUED
   127.0.0.1:6379> INCR id
   QUEUED
   127.0.0.1:6379> INCR tl
   QUEUED
   127.0.0.1:6379> INCR tl
   QUEUED
   127.0.0.1:6379> get tl
   QUEUED
   127.0.0.1:6379> exec
   1) OK
   2) "12"
   3) (integer) 13
   4) (integer) 1
   5) (integer) 2
   6) "2"
   127.0.0.1:6379>
   ```

   - 放弃事务

   ```shell
   127.0.0.1:6379> MULTI
   OK
   127.0.0.1:6379> set id 12
   QUEUED
   127.0.0.1:6379> get id
   QUEUED
   127.0.0.1:6379> INCR id
   QUEUED
   127.0.0.1:6379> INCR tl
   QUEUED
   127.0.0.1:6379> INCR tl
   QUEUED
   127.0.0.1:6379> get tl
   QUEUED
   127.0.0.1:6379> discard
   OK
   127.0.0.1:6379>
   ```

   - 全体连坐: 语法上的错误

   ```shell
   127.0.0.1:6379> MULTI
   OK
   127.0.0.1:6379> set name zz
   QUEUED
   127.0.0.1:6379> get name
   QUEUED
   127.0.0.1:6379> incr tl
   QUEUED
   127.0.0.1:6379> get tl
   QUEUED
   127.0.0.1:6379> set email
   (error) ERR wrong number of arguments for 'set' command
   127.0.0.1:6379> exec
   (error) EXECABORT Transaction discarded because of previous errors.
   127.0.0.1:6379> get tl
   "2"
   ```

   - 冤有头债有主: 运行时错误[为了性能]

   ```shell
   127.0.0.1:6379> MULTI
   OK
   127.0.0.1:6379> set age 11
   QUEUED
   127.0.0.1:6379> INCR ti
   QUEUED
   127.0.0.1:6379> set emial zack
   QUEUED
   127.0.0.1:6379> INCR emial
   QUEUED
   127.0.0.1:6379> get age
   QUEUED
   127.0.0.1:6379> exec
   1) OK
   2) (integer) 1
   3) OK
   4) (error) ERR value is not an integer or out of range
   5) "11"
   127.0.0.1:6379>
   ```

4. watch

   - watch 类似乐观锁[CAS], 事务提交时, 如果 key 的值被别人修改了, 则这个事务放弃
   - 放弃之后会返回 Nullmuti-bulk 应答通知调用者事务执行失败

5. 特点

   - 单独的隔离操作: 事务中的命令会序列化顺序且排他的执行, 不会被打断
   - 没有隔离级别的概念: 提交之前都不会执行
   - 没有原子性: redis 中同一事物如果有一条失败, 其他命令依旧可以执行成功
   - 不支持回滚: 官方说明是为了保证 redis 的快速和简单

6. CAS: 事务

   - 原子性: 不保证原子性[语法性错误会全体回滚{如参数个数}, 具体的指令错误不影响其他的{如 str+1}] 事务中的所有命令都将会被串行化的顺序执行, 不能加三
   - 事务数据的持久化: `当使用Append-Only模式时, Redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃, 如电源故障导致的宕机, 那么此时也许只有部分数据被写入到磁盘, 而另外一部分数据却已经丢失。Redis服务器会在重新启动时执行一系列必要的一致性检测, 一旦发现类似问题, 就会立即退出并给出相应的错误提示`
   - WATCH+ CAS 可以实现 incr: `WATCH mykey val = GET mykey val = val + 1 MULTI SET mykey $val EXEC`
