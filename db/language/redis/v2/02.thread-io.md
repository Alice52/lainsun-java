## thread: 快

1. redis 线程问题: **单线程[工作线程=输入计算输出]**

   - Redis 的单线程指的是 Redis 的网络 IO[6.x 之后这个也独立出去]以及**键值对指令读写是由一个线程来执行**的
   - 对于 Redis 的持久化、集群数据同步、异步删除等都是其他线程执行
   - 运算都是内存级别的运算与存储:

     1. 比机械硬盘快 10w 倍, 比固态[IO 速度]快 1k 倍; 如果命中 cache Line 会更快
        ![avatar](https://user-images.githubusercontent.com/42330329/169217604-3034cca1-b6ca-4f76-b95c-8843e9f2782a.png)

   - 单线程, 不需要线程切换上下文[很消耗资源]和竞争条件, 不需要考虑并发锁问题
     1. 多线程可以更加充分的利用 cpu 资源, 但是需要良好的设计架构和并发控制, 增加复杂度, 且随着线程越来越多会导致性能下降
     2. 单线程不需要上下文切换可以充分利用硬件缓存
     3. 使用了单线程{无竞争条件和锁}后, 可维护性高: 多线程{线程本身也消耗资源}却引入了程序执行顺序的不确定性, 带来并发读写的一系列问题, 增加了系统复杂度, 同时可能存在线程切换, 甚至加锁解锁/死锁造成的性能损耗
     4. 单线程机制让 Redis 内部实现的复杂度大大降低, Hash 的惰性 Rehash/Lpush 等等『线程不安全』的命令都可以无锁进行
     5. 且 **CPU 不是 Redis 的瓶颈**, Redis 的瓶颈最有可能是机器内存的大小或者网络带宽, 所以不需要过分压榨 CPU
     6. pipelining 模式下, 100wqps: 程序是 hashtable, 时间复杂度 O(1)/O(log(n)) 不怎么占用 cpu
   - 非阻塞 IO - IO[网络 I/O] 多路[多个 TCP 连接]复用[共用一个线程或进程]:
     1. redis 采用 I/O 多路复用技术, 并发处理连接
     2. redis 利用 epoll + 自己实现的简单的事件框架
     3. epoll 中的读、写、关闭、连接都转化成了事件, 利用 epoll 的多路复用特性, 绝不在 IO 上浪费一点时间
     4. Redis 线程不会阻塞在某一个特定的监听或已连接套接字上
        - 不会阻塞在某一个特定的客户端请求处理上
        - 正因为此, Redis 可以同时和多个客户端连接并处理请求, 从而提升并发性
     5. 将连接信息和事件放到队列中, 依次放到文件事件分派器
     6. 事件分派器将事件分发给事件处理器
     7. others: 多路复用 IO 实现: select, poll, **epoll**

   ![avatar](/static/image/db/rredisthread.png)
   ![avatar](https://user-images.githubusercontent.com/42330329/169217763-b8e8bccd-f1d2-4a03-a0e0-dc369a23e70f.png)

   - 合理的数据结构
   - 数据编码: 根据字符串的长度及元素的个数适配不同的编码格式

2. 线程安全问题

   - 计算线程是串行的单线程: 安全
   - 但是使用 redis 时业务上要自行保证顺序: FIFO

3. redis 6.x 使用多线程处理网络 IO

   - 核心工作线程还是 1 个
   - 5.x
     ![image](https://user-images.githubusercontent.com/42330329/169222817-6c23d685-5456-4faf-9486-b7e0bc99210f.png)
   - 6.x
     ![image](https://user-images.githubusercontent.com/42330329/169222875-80bfd0a3-e9b2-4d81-902a-7de1791f2139.png)

4. 数据结构

   - [link](./03.data-struct.md)
   - 整个数据库就是一个全局哈希表, 而哈希表的时间复杂度是 O(1)
   - 只需要计算每个键的哈希值, 便知道对应的哈希桶位置, 定位桶里面的 entry 找到对应数据, 这个也是 Redis 快的原因之一
   - quicklist: ziplist + linkedlist

5. Redis 为了追求快, 使用了两个全局哈希表
   - 用于 rehash 操作, 增加现有的哈希桶数量, 减少哈希冲突

## 线程

1.  6.0 之前说的单线程

    - redis 在处理客户端的请求时, 包括获取(socket 读)、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理, 这就是所谓的「单线程」
    - 有些命令操作可以用后台线程或子进程执行: 数据删除、快照生成、AOF 重写

2.  6.0 将输出输入线程独立的原因

    - 随着硬件性能提升, Redis 的性能瓶颈可能出现网络 IO 的读写
    - **单个线程处理网络读写的速度跟不上底层网络硬件的速度**

3.  读写网络的 read/write 系统调用占用了 Redis 执行期间大部分 CPU 时间, 瓶颈主要在于网络的 IO 消耗, 优化主要有两个方向:

    - 提高网络 IO 性能: 零拷贝技术或者 DPDK{DPDK 应用程序运行 OS 的用户态, 利用自身提供的数据面库进行收发包处理, 绕过了 Linux 内核态协议栈, **以提升报文处理效率**} 技术
    - **使用多线程充分利用多核**, 提高网络请求读写的并行度: 典型的实现比如 Memcached

4.  Redis 6.0 的多线程默认是禁用的, 只使用主线程

    - 如需开启需要修改 redis.conf 配置文件:

      ```conf
      io-threads-do-reads yes
      # 官方有一个建议: 线程数一定要小于机器核数, 官方认为超过了 8 个基本就没什么意义了
      # 4 核的机器建议设置为 2 或 3 个线程
      # 8 核的建议设置为 6 个线程
      io-threads 4
      ```
